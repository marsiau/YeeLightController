import re #Regex library
import socket
from threading import Thread #Multithreding library

#----------Variables----------
DEBUGGING = True #Turn on/off debugging messages
RUNNING = True #Keeps the search thread running
MCAST_GRP = '239.255.255.250' #Multicast group
MCAST_PORT = '1982' #Multicast port
"""
The searching message generated by 3rd device should follow below format and rules and
being sent to multi-cast address 239.255.255.250:1982 over UDP.
...
We choose to send multi-cast messages to port 1982 instead of
standard SSDP port 1900. This is to avoid excessive multi-cast messages being received by
both smart LED and 3rd party devices.(Yeelight_Inter-Operation_Spec.pdf)
"""

#----------Inline----------
#Creating socket
scan_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
#SOCK_DGRAM <- allows UDP connection (SOCK.STREAM for TCP)
  
#----------Functions----------
def debug(msg):
	if DEBUGGING:
		print(msg)

def print_cli_usage():
	"""Prints viable user commands"""
	print("Usage:")
	print("  q|quit: quit bulb manager")
	print("  h|help: print this message")
	print("  t|toggle <idx>: toggle bulb indicated by idx")
	print("  b|bright <idx> <bright>: set brightness of bulb with label <idx>")
	print("  r|refresh: refresh bulb list")
	print("  l|list: lsit all managed bulbs")

def send_search_broadcast():
	"""Multicast search request to all hosts in LAN, do not wait for response"""
	multicase_address = (MCAST_GRP, MCAST_PORT) #Tuple with Multicast group and port
	debug("Send search request")
	msg = "M-SEARCH * HTTP/1.1\r\n" 
	msg = msg + "HOST: 239.255.255.250:1982\r\n"
	msg = msg + "MAN: \"ssdp:discover\"\r\n"
	msg = msg + "ST: wifi_bulb"
	#Sends SSDP? search request to the socket
	scan_socket.sendto(msg, multicase_address)

def get_param_value(data, param):
	'''
	match line of 'param = value'
	'''
	param_re = re.compile(param+":\s*([ -~]*)") #match all printable characters
	match = param_re.search(data)
	value=""
	if match != None:
		value = match.group(1)
		return value

def handle_search_response(data):
	"""
	Parse search response and extract all interested data.
	If new bulb is found, insert it into dictionary of managed bulbs.
	
	Response example:
	HTTP/1.1 200 OK
	Cache-Control: max-age=3600
	Date:
	Ext:
	Location: yeelight://192.168.1.239:55443
	Server: POSIX UPnP/1.0 YGLC/1
	id: 0x000000000015243f
	model: color
	fw_ver: 18
	support: get_prop set_default set_power toggle set_bright start_cf stop_cf set_scene
	cron_add cron_get cron_del set_ct_abx set_rgb
	power: on
	bright: 100
	color_mode: 2
	ct: 4000
	rgb: 16711680
	hue: 100
	sat: 35
	name: my_bulb
	(Yeelight_Inter-Operation_Spec.pdf)
	"""
	#Compile the pattern into regex object
	location_re = re.compile("Location.*yeelight[^0-9]*([0-9]{1,3}(\.[0-9]{1,3}){3}):([0-9]*)")
	#https://regex101.com/ <-explanation. Grabs (Ex): Location: yeelight://192.168.1.239:55443
	# match() only attempts to match a pattern at the beginning of a string
	match = location_re.search(data)
	if match == None:
		debug( "invalid data received: " + data )
		return
	#	
	host_ip = match.group(1) #host_ip = /192.168.1.239(Ex)
	#Check if bulb is already known
	if detected_bulbs.has_key(host_ip):
		#If known, give an id
		bulb_id = detected_bulbs[host_ip][0]
	else:
		#If not give a new one
		bulb_id = len(detected_bulbs)+1
	host_port = match.group(3)
	model = get_param_value(data, "model")
	power = get_param_value(data, "power")
	bright = get_param_value(data, "bright")
	rgb = get_param_value(data, "rgb")
	# use two dictionaries to store index->ip and ip->bulb map
	detected_bulbs[host_ip] = [bulb_id, model, power, bright, rgb, host_port]
	bulb_idx2ip[bulb_id] = host_ip

#------------------------------------------------------

def bulbs_detection_loop():
	"""A standalone thread broadcasting search request and listening on all responses"""
	debug("bulbs_detection_loop running") #msg if debuging
	search_interval=30000
	read_interval=100
	time_elapsed=0

	while RUNNING:
		#send search broadcast every "search_interval"
		if time_elapsed%search_interval == 0:
		  send_search_broadcast()#Constructs and sends a search request to a socket scan_scocket
		
		# scanner
		#TODO change to a normal loop?
		while True:
			try:
				data = scan_socket.recv(2048)#Receives data from the socket
			except socket.error as e:
				err = e.args[0]
				if err == errno.EAGAIN or err == errno.EWOULDBLOCK:
					break
				else:
					print(e)
					sys.exit(1)
		handle_search_response(data)
#------------------------------------------------------
	# passive listener 
	while True:
		try:
			data, addr = listen_socket.recvfrom(2048)
		except socket.error as e:
			err = e.args[0]
			if err == errno.EAGAIN or err == errno.EWOULDBLOCK:
				break
			else:
				print (e)
				sys.exit(1)
		handle_search_response(data)
    #TODO reset time_elapsed?
	time_elapsed+=read_interval
	sleep(read_interval/1000.0)
	scan_socket.close()
	listen_socket.close()


#----------Main----------
print("Hello there buddy\n")
print_cli_usage()

# Start the bulb detection thread
#Creates a seperate thread that executes bulbs_detection_loop 
DetectionThread = Thread(target=bulbs_detection_loop)
#Start the thread
DetectionThread.start() 

